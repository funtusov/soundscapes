<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EtherPad Soundscape</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            touch-action: none; /* Critical for mobile */
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            transition: opacity 0.5s;
        }

        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .btn {
            padding: 15px 30px;
            border: 1px solid #00ffcc;
            color: #00ffcc;
            background: transparent;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
        }

        .btn:active, .btn:hover {
            background: #00ffcc;
            color: #000;
            box-shadow: 0 0 15px #00ffcc;
        }

        .hud {
            position: absolute;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            padding: 10px;
            text-shadow: 0 1px 2px black;
            z-index: 10;
        }
        
        .hud-tl { top: 10px; left: 10px; }
        .hud-tr { top: 10px; right: 10px; text-align: right; }
        .hud-bl { bottom: 60px; left: 10px; }
        .hud-br { bottom: 60px; right: 10px; text-align: right; }

        .mode-selector {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid rgba(0, 255, 204, 0.3);
            z-index: 15;
        }

        .mode-btn {
            padding: 8px 12px;
            border: 1px solid rgba(0, 255, 204, 0.4);
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.7rem;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .mode-btn.active {
            border-color: #00ffcc;
            color: #00ffcc;
            background: rgba(0, 255, 204, 0.15);
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }

        .mode-btn:active {
            transform: scale(0.95);
        }

    </style>
</head>
<body>

    <!-- Start Overlay -->
    <div id="overlay">
        <h1 class="text-3xl mb-2 font-light tracking-widest text-white">ETHERPAD</h1>
        <p class="mb-8 text-gray-400 text-sm">Headphones Recommended</p>
        <button id="startBtn" class="btn">Initialize System</button>
    </div>

    <!-- HUD Elements -->
    <div class="hud hud-tl">
        FREQ: <span id="val-freq">0</span> Hz<br>
        FILT: <span id="val-tilt">--</span>
    </div>
    <div class="hud hud-tr">
        SERIES: <span id="val-harm">Pure</span><br>
        MOTION: <span id="val-motion">--</span>
    </div>
    <div class="hud hud-bl" id="hud-bl">X: Pitch | γ: Pan</div>
    <div class="hud hud-br" id="hud-br">Y: Harmonics | β: Filter</div>

    <canvas id="canvas"></canvas>

    <!-- Mode Selector -->
    <div class="mode-selector" id="modeSelector" style="display: none;">
        <button class="mode-btn active" data-mode="wavetable">Wave</button>
        <button class="mode-btn" data-mode="theremin">Scale</button>
        <button class="mode-btn" data-mode="fm">FM</button>
        <button class="mode-btn" data-mode="chords">Chords</button>
        <button class="mode-btn" data-mode="karplus">String</button>
        <button class="mode-btn" data-mode="granular">Grain</button>
    </div>

    <script>
        /**
         * AUDIO ENGINE - Multi-mode Synthesizer
         */
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.filter = null;
                this.panner = null;
                this.delayFeedback = null;
                this.analyser = null;
                this.isPlaying = false;
                this.dataArray = null;

                // Current synthesis mode
                this.mode = 'wavetable';

                // Mode-specific nodes
                this.nodes = {};

                // Multi-touch tracking
                this.touches = new Map();

                // Orientation parameters
                this.orientationParams = {
                    pan: 0,
                    filterMod: 0,
                    lfoRate: 0,
                    shake: 0
                };

                // Scale for theremin mode (pentatonic minor)
                this.scale = [0, 3, 5, 7, 10, 12, 15, 17, 19, 22, 24];

                // Silent audio for iOS
                this.silentAudio = new Audio("data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAAYYNAAAAAAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAAYYNAAAAAAAAAAAAAAAAAAAA");
                this.silentAudio.loop = true;
            }

            init() {
                if (this.ctx) {
                    try { this.ctx.close(); } catch(e) {}
                }

                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                // Master chain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0;

                // Analyser
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 4096;
                this.analyser.smoothingTimeConstant = 0.1;
                this.analyser.minDecibels = -100;
                this.analyser.maxDecibels = -10;
                this.dataArray = new Float32Array(this.analyser.frequencyBinCount);

                // Filter
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.Q.value = 1;
                this.filter.frequency.value = 8000;

                // Panner
                this.panner = this.ctx.createStereoPanner();

                // Delay
                const delayL = this.ctx.createDelay();
                const delayR = this.ctx.createDelay();
                this.delayFeedback = this.ctx.createGain();
                delayL.delayTime.value = 0.25;
                delayR.delayTime.value = 0.35;
                this.delayFeedback.gain.value = 0.25;

                // Routing
                this.filter.connect(this.panner);
                this.panner.connect(this.masterGain);
                this.masterGain.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);

                this.masterGain.connect(delayL);
                this.masterGain.connect(delayR);
                delayL.connect(this.delayFeedback);
                delayR.connect(this.delayFeedback);
                this.delayFeedback.connect(delayL);
                this.delayFeedback.connect(delayR);
                delayL.connect(this.analyser);
                delayR.connect(this.analyser);

                this.initMode(this.mode);
            }

            initMode(mode) {
                // Clean up previous mode
                this.cleanupMode();
                this.mode = mode;

                switch(mode) {
                    case 'wavetable': this.initWavetable(); break;
                    case 'theremin': this.initTheremin(); break;
                    case 'fm': this.initFM(); break;
                    case 'chords': this.initChords(); break;
                    case 'karplus': this.initKarplus(); break;
                    case 'granular': this.initGranular(); break;
                }

                this.updateHUDLabels();
            }

            cleanupMode() {
                // Stop and disconnect all mode-specific nodes
                if (this.nodes.oscillators) {
                    this.nodes.oscillators.forEach(o => {
                        try { o.osc.stop(); o.osc.disconnect(); o.gain.disconnect(); } catch(e) {}
                    });
                }
                if (this.nodes.noiseSource) {
                    try { this.nodes.noiseSource.stop(); this.nodes.noiseSource.disconnect(); } catch(e) {}
                }
                if (this.nodes.lfo) {
                    try { this.nodes.lfo.stop(); this.nodes.lfo.disconnect(); } catch(e) {}
                }
                this.nodes = {};
            }

            // ========== WAVETABLE MODE ==========
            initWavetable() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sawtooth';
                osc.frequency.value = 220;
                gain.gain.value = 0;

                osc.connect(gain);
                gain.connect(this.filter);
                osc.start();

                // LFO for subtle movement
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = 0.5;
                lfoGain.gain.value = 0;
                lfo.connect(lfoGain);
                lfoGain.connect(osc.detune);
                lfo.start();

                this.nodes = { osc, gain, lfo, lfoGain };
            }

            updateWavetable(x, y) {
                const now = this.ctx.currentTime;
                const freq = 55 * Math.pow(2, x * 3); // 55Hz to 440Hz (3 octaves)

                this.nodes.osc.frequency.setTargetAtTime(freq, now, 0.02);

                // Y morphs waveform: sine -> triangle -> sawtooth -> square
                if (y < 0.25) {
                    this.nodes.osc.type = 'sine';
                } else if (y < 0.5) {
                    this.nodes.osc.type = 'triangle';
                } else if (y < 0.75) {
                    this.nodes.osc.type = 'sawtooth';
                } else {
                    this.nodes.osc.type = 'square';
                }

                document.getElementById('val-freq').innerText = Math.round(freq);
                document.getElementById('val-harm').innerText = this.nodes.osc.type;
            }

            // ========== THEREMIN (SCALE) MODE ==========
            initTheremin() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const vibrato = this.ctx.createOscillator();
                const vibratoGain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 440;
                gain.gain.value = 0;

                vibrato.frequency.value = 5;
                vibratoGain.gain.value = 0;

                vibrato.connect(vibratoGain);
                vibratoGain.connect(osc.frequency);
                osc.connect(gain);
                gain.connect(this.filter);

                osc.start();
                vibrato.start();

                this.nodes = { osc, gain, vibrato, vibratoGain };
            }

            updateTheremin(x, y) {
                const now = this.ctx.currentTime;

                // Quantize X to scale
                const noteIndex = Math.floor(x * this.scale.length);
                const semitone = this.scale[Math.min(noteIndex, this.scale.length - 1)];
                const freq = 220 * Math.pow(2, semitone / 12);

                this.nodes.osc.frequency.setTargetAtTime(freq, now, 0.05);

                // Y controls vibrato depth
                const vibratoDepth = y * 15;
                this.nodes.vibratoGain.gain.setTargetAtTime(vibratoDepth, now, 0.05);

                // Note name
                const noteNames = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
                const noteName = noteNames[semitone % 12];

                document.getElementById('val-freq').innerText = Math.round(freq);
                document.getElementById('val-harm').innerText = noteName + Math.floor(3 + semitone / 12);
            }

            // ========== FM SYNTHESIS MODE ==========
            initFM() {
                const carrier = this.ctx.createOscillator();
                const carrierGain = this.ctx.createGain();
                const modulator = this.ctx.createOscillator();
                const modulatorGain = this.ctx.createGain();

                carrier.type = 'sine';
                carrier.frequency.value = 220;
                modulator.type = 'sine';
                modulator.frequency.value = 220;

                carrierGain.gain.value = 0;
                modulatorGain.gain.value = 0;

                modulator.connect(modulatorGain);
                modulatorGain.connect(carrier.frequency);
                carrier.connect(carrierGain);
                carrierGain.connect(this.filter);

                carrier.start();
                modulator.start();

                this.nodes = { carrier, carrierGain, modulator, modulatorGain, ratio: 1 };
            }

            updateFM(x, y) {
                const now = this.ctx.currentTime;
                const carrierFreq = 55 * Math.pow(2, x * 3);

                // Y controls modulation index (brightness)
                const modIndex = y * 8;
                const modFreq = carrierFreq * this.nodes.ratio;

                this.nodes.carrier.frequency.setTargetAtTime(carrierFreq, now, 0.02);
                this.nodes.modulator.frequency.setTargetAtTime(modFreq, now, 0.02);
                this.nodes.modulatorGain.gain.setTargetAtTime(modIndex * carrierFreq, now, 0.02);

                document.getElementById('val-freq').innerText = Math.round(carrierFreq);
                document.getElementById('val-harm').innerText = 'idx:' + modIndex.toFixed(1);
            }

            // ========== CHORDS MODE ==========
            initChords() {
                this.nodes = { voices: new Map() };
            }

            updateChords(x, y, touchId = 0) {
                const now = this.ctx.currentTime;

                // Get or create voice for this touch
                if (!this.nodes.voices.has(touchId)) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.connect(gain);
                    gain.connect(this.filter);
                    gain.gain.value = 0;
                    osc.start();
                    this.nodes.voices.set(touchId, { osc, gain });
                }

                const voice = this.nodes.voices.get(touchId);

                // Quantize to pentatonic
                const noteIndex = Math.floor(x * 15);
                const octave = Math.floor(noteIndex / 5);
                const degree = noteIndex % 5;
                const pentatonic = [0, 2, 4, 7, 9];
                const semitone = octave * 12 + pentatonic[degree];
                const freq = 110 * Math.pow(2, semitone / 12);

                voice.osc.frequency.setTargetAtTime(freq, now, 0.02);
                voice.gain.gain.setTargetAtTime(0.3, now, 0.02);

                document.getElementById('val-freq').innerText = this.nodes.voices.size + ' voices';
                document.getElementById('val-harm').innerText = Math.round(freq) + 'Hz';
            }

            stopChordVoice(touchId) {
                if (this.nodes.voices && this.nodes.voices.has(touchId)) {
                    const voice = this.nodes.voices.get(touchId);
                    const now = this.ctx.currentTime;
                    voice.gain.gain.setTargetAtTime(0, now, 0.1);
                    setTimeout(() => {
                        try {
                            voice.osc.stop();
                            voice.osc.disconnect();
                            voice.gain.disconnect();
                        } catch(e) {}
                        this.nodes.voices.delete(touchId);
                    }, 200);
                }
            }

            // ========== KARPLUS-STRONG MODE ==========
            initKarplus() {
                this.nodes = {
                    activeVoices: [],
                    lastPluck: 0
                };
            }

            pluckString(freq, brightness) {
                const now = this.ctx.currentTime;

                // Throttle plucks
                if (now - this.nodes.lastPluck < 0.05) return;
                this.nodes.lastPluck = now;

                // Create noise burst
                const bufferSize = this.ctx.sampleRate / freq;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);

                // Fill with filtered noise
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                // Simple lowpass on the noise based on brightness
                for (let i = 1; i < bufferSize; i++) {
                    data[i] = data[i] * brightness + data[i-1] * (1 - brightness);
                }

                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.loop = true;

                // Decay envelope
                const env = this.ctx.createGain();
                env.gain.setValueAtTime(0.5, now);
                env.gain.exponentialRampToValueAtTime(0.001, now + 2);

                // Feedback filter for string decay
                const lpf = this.ctx.createBiquadFilter();
                lpf.type = 'lowpass';
                lpf.frequency.value = freq * (1 + brightness * 3);

                source.connect(lpf);
                lpf.connect(env);
                env.connect(this.filter);
                source.start();
                source.stop(now + 2.5);

                // Cleanup
                setTimeout(() => {
                    try { source.disconnect(); env.disconnect(); lpf.disconnect(); } catch(e) {}
                }, 3000);
            }

            updateKarplus(x, y) {
                // Quantize to scale
                const noteIndex = Math.floor(x * 12);
                const semitone = this.scale[Math.min(noteIndex, this.scale.length - 1)];
                const freq = 110 * Math.pow(2, semitone / 12);

                this.pluckString(freq, 0.3 + y * 0.6);

                document.getElementById('val-freq').innerText = Math.round(freq);
                document.getElementById('val-harm').innerText = 'bright:' + (0.3 + y * 0.6).toFixed(1);
            }

            // ========== GRANULAR MODE ==========
            initGranular() {
                // Create a rich drone using multiple detuned oscillators
                const oscs = [];
                const baseFreq = 110;

                for (let i = 0; i < 6; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.type = ['sine', 'triangle', 'sine'][i % 3];
                    osc.frequency.value = baseFreq * (1 + i * 0.5);
                    osc.detune.value = (Math.random() - 0.5) * 20;

                    gain.gain.value = 0;

                    osc.connect(gain);
                    gain.connect(this.filter);
                    osc.start();

                    oscs.push({ osc, gain });
                }

                // LFO for movement
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = 0.1;
                lfoGain.gain.value = 10;
                lfo.connect(lfoGain);
                lfo.start();

                // Connect LFO to oscillator frequencies
                oscs.forEach(o => lfoGain.connect(o.osc.frequency));

                this.nodes = { oscs, lfo, lfoGain };
            }

            updateGranular(x, y) {
                const now = this.ctx.currentTime;
                const baseFreq = 55 + x * 165; // 55-220 Hz

                this.nodes.oscs.forEach((o, i) => {
                    const freq = baseFreq * (1 + i * 0.5 * (0.5 + y));
                    o.osc.frequency.setTargetAtTime(freq, now, 0.1);

                    // Y controls mix of oscillators
                    const level = (i < 2) ? 0.3 : (y > i * 0.15 ? 0.2 : 0);
                    o.gain.gain.setTargetAtTime(level, now, 0.1);
                });

                // Y also controls LFO rate
                this.nodes.lfo.frequency.setTargetAtTime(0.05 + y * 0.5, now, 0.1);

                document.getElementById('val-freq').innerText = Math.round(baseFreq);
                document.getElementById('val-harm').innerText = 'density:' + (y * 100).toFixed(0) + '%';
            }

            // ========== COMMON METHODS ==========
            updateHUDLabels() {
                const labels = {
                    wavetable: ['X: Pitch | γ: Pan', 'Y: Waveform | β: Filter'],
                    theremin: ['X: Note | γ: Pan', 'Y: Vibrato | β: Filter'],
                    fm: ['X: Pitch | γ: Pan', 'Y: Mod Index | β: Filter'],
                    chords: ['X: Note | γ: Pan', 'Y: (multi-touch) | β: Filter'],
                    karplus: ['X: Note | γ: Pan', 'Y: Brightness | β: Filter'],
                    granular: ['X: Base Freq | γ: Pan', 'Y: Density | β: Filter']
                };

                const l = labels[this.mode] || labels.wavetable;
                document.getElementById('hud-bl').innerText = l[0];
                document.getElementById('hud-br').innerText = l[1];
            }

            resume() {
                this.silentAudio.play().catch(e => {});
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }

            start(touchId = 0) {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();

                const now = this.ctx.currentTime;

                if (this.mode === 'chords') {
                    // Handled per-voice
                } else if (this.mode === 'karplus') {
                    // Triggered on update
                } else {
                    // Fade in
                    if (this.nodes.gain) {
                        this.nodes.gain.gain.setTargetAtTime(0.4, now, 0.05);
                    }
                    if (this.nodes.carrierGain) {
                        this.nodes.carrierGain.gain.setTargetAtTime(0.4, now, 0.05);
                    }
                    if (this.nodes.oscs) {
                        this.nodes.oscs.forEach(o => o.gain.gain.setTargetAtTime(0.2, now, 0.1));
                    }
                }

                this.masterGain.gain.setTargetAtTime(0.7, now, 0.05);
                this.isPlaying = true;
            }

            stop(touchId = 0) {
                if (!this.ctx) return;
                const now = this.ctx.currentTime;

                if (this.mode === 'chords') {
                    this.stopChordVoice(touchId);
                    if (this.nodes.voices && this.nodes.voices.size === 0) {
                        this.masterGain.gain.setTargetAtTime(0, now, 0.3);
                        this.isPlaying = false;
                    }
                } else if (this.mode === 'karplus') {
                    // Let strings ring out
                    this.isPlaying = false;
                } else {
                    if (this.nodes.gain) {
                        this.nodes.gain.gain.setTargetAtTime(0, now, 0.1);
                    }
                    if (this.nodes.carrierGain) {
                        this.nodes.carrierGain.gain.setTargetAtTime(0, now, 0.1);
                    }
                    if (this.nodes.oscs) {
                        this.nodes.oscs.forEach(o => o.gain.gain.setTargetAtTime(0, now, 0.2));
                    }
                    this.masterGain.gain.setTargetAtTime(0, now, 0.3);
                    this.isPlaying = false;
                }
            }

            update(x, y, touchId = 0) {
                if (!this.ctx) return;

                switch(this.mode) {
                    case 'wavetable': this.updateWavetable(x, y); break;
                    case 'theremin': this.updateTheremin(x, y); break;
                    case 'fm': this.updateFM(x, y); break;
                    case 'chords': this.updateChords(x, y, touchId); break;
                    case 'karplus': this.updateKarplus(x, y); break;
                    case 'granular': this.updateGranular(x, y); break;
                }
            }

            getAnalysis() {
                if (this.analyser && this.dataArray) {
                    this.analyser.getFloatFrequencyData(this.dataArray);
                    return this.dataArray;
                }
                return null;
            }

            updateOrientation(beta, gamma) {
                if (!this.ctx) return;
                const now = this.ctx.currentTime;

                // Pan from gamma
                const clampedGamma = Math.max(-45, Math.min(45, gamma || 0));
                const pan = clampedGamma / 45;
                this.orientationParams.pan = pan;
                this.panner.pan.setTargetAtTime(pan, now, 0.05);

                // Filter from beta
                const clampedBeta = Math.max(0, Math.min(90, beta || 0));
                const filterMod = clampedBeta / 90;
                this.orientationParams.filterMod = filterMod;

                const tiltCutoff = 300 + ((1 - filterMod) * 7000);
                this.filter.frequency.setTargetAtTime(tiltCutoff, now, 0.1);

                const targetQ = 0.5 + (filterMod * 10);
                this.filter.Q.setTargetAtTime(targetQ, now, 0.1);

                document.getElementById('val-tilt').innerText =
                    `${Math.round(tiltCutoff)}Hz Q:${targetQ.toFixed(1)}`;
            }

            updateMotion(acceleration, rotationRate) {
                if (!this.ctx) return;
                const now = this.ctx.currentTime;

                if (rotationRate) {
                    const rotMagnitude = Math.sqrt(
                        (rotationRate.alpha || 0) ** 2 +
                        (rotationRate.beta || 0) ** 2 +
                        (rotationRate.gamma || 0) ** 2
                    );
                    this.orientationParams.lfoRate = rotMagnitude;

                    // Apply to FM ratio if in FM mode
                    if (this.mode === 'fm' && this.nodes.ratio !== undefined) {
                        this.nodes.ratio = 1 + Math.floor(rotMagnitude / 30);
                    }
                }

                if (acceleration) {
                    const accMagnitude = Math.sqrt(
                        (acceleration.x || 0) ** 2 +
                        (acceleration.y || 0) ** 2 +
                        (acceleration.z || 0) ** 2
                    );
                    this.orientationParams.shake = accMagnitude;

                    if (accMagnitude > 12) {
                        this.delayFeedback.gain.setTargetAtTime(0.6, now, 0.02);
                        setTimeout(() => {
                            if (this.ctx) {
                                this.delayFeedback.gain.setTargetAtTime(0.25, this.ctx.currentTime, 0.3);
                            }
                        }, 300);
                    }

                    const motionLabel = accMagnitude > 12 ? 'SHAKE!' :
                                       accMagnitude > 3 ? 'Active' : 'Steady';
                    document.getElementById('val-motion').innerText = motionLabel;
                }
            }
        }

        /**
         * VISUAL ENGINE
         */
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        let cursorX = 0;
        let cursorY = 0;
        let isTouching = false;
        let ripples = [];
        let animationFrameId;

        // Spectrogram buffer (stores recent FFT frames)
        const SPECTROGRAM_HISTORY = 120; // number of time frames to show
        const MEL_BINS = 256; // number of mel frequency bins
        let spectrogramBuffer = [];

        // Mel scale conversion helpers
        function hzToMel(hz) {
            return 2595 * Math.log10(1 + hz / 700);
        }

        function melToHz(mel) {
            return 700 * (Math.pow(10, mel / 2595) - 1);
        }

        // Create mel filterbank (maps FFT bins to mel bins)
        function createMelFilterbank(fftSize, sampleRate, numMelBins, minFreq, maxFreq) {
            const numFftBins = fftSize / 2;
            const melMin = hzToMel(minFreq);
            const melMax = hzToMel(maxFreq);
            const melPoints = [];

            // Create equally spaced mel points
            for (let i = 0; i <= numMelBins + 1; i++) {
                melPoints.push(melToHz(melMin + (melMax - melMin) * i / (numMelBins + 1)));
            }

            // Convert to FFT bin indices
            const binPoints = melPoints.map(freq => Math.floor((fftSize + 1) * freq / sampleRate));

            // Create triangular filters
            const filterbank = [];
            for (let i = 0; i < numMelBins; i++) {
                const filter = new Float32Array(numFftBins);
                const startBin = binPoints[i];
                const centerBin = binPoints[i + 1];
                const endBin = binPoints[i + 2];

                for (let j = startBin; j < centerBin && j < numFftBins; j++) {
                    filter[j] = (j - startBin) / (centerBin - startBin);
                }
                for (let j = centerBin; j < endBin && j < numFftBins; j++) {
                    filter[j] = (endBin - j) / (endBin - centerBin);
                }
                filterbank.push(filter);
            }
            return filterbank;
        }

        let melFilterbank = null;

        function initMelFilterbank() {
            if (audio.ctx) {
                melFilterbank = createMelFilterbank(
                    audio.analyser.fftSize,
                    audio.ctx.sampleRate,
                    MEL_BINS,
                    20,    // min frequency
                    8000   // max frequency
                );
            }
        }

        function fftToMel(fftData) {
            if (!melFilterbank) return null;
            const melSpectrum = new Float32Array(MEL_BINS);

            for (let i = 0; i < MEL_BINS; i++) {
                // For dB values, we need to convert to linear, average, then back to dB
                let linearSum = 0;
                let filterSum = 0;
                for (let j = 0; j < fftData.length; j++) {
                    // fftData is already in dB, convert to linear power
                    const linearPower = Math.pow(10, fftData[j] / 10);
                    linearSum += linearPower * melFilterbank[i][j];
                    filterSum += melFilterbank[i][j];
                }
                // Average and convert back to dB
                if (filterSum > 0) {
                    linearSum = linearSum / filterSum;
                }
                // Convert back to dB
                melSpectrum[i] = 10 * Math.log10(linearSum + 1e-10);
            }
            return melSpectrum;
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        function drawGrid() {
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 255, 204, 0.1)';
            
            // Draw grid
            const stepX = width / 8;
            for(let i=0; i<=width; i+=stepX) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, height); ctx.stroke();
            }
            const stepY = height / 8;
            for(let i=0; i<=height; i+=stepY) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(width, i); ctx.stroke();
            }
        }

        function drawSpectrogram() {
            const data = audio.getAnalysis();
            if (!data) return;

            // Initialize mel filterbank if needed
            if (!melFilterbank) {
                initMelFilterbank();
            }

            // Convert FFT to mel spectrum
            const melSpectrum = fftToMel(data);
            if (!melSpectrum) return;

            // Add to buffer
            spectrogramBuffer.push(melSpectrum);
            if (spectrogramBuffer.length > SPECTROGRAM_HISTORY) {
                spectrogramBuffer.shift();
            }

            // Draw spectrogram (time on x-axis, frequency on y-axis)
            const colWidth = Math.ceil(width / SPECTROGRAM_HISTORY);
            const rowHeight = Math.ceil(height / MEL_BINS);

            // Fixed normalization range for stability (dB scale)
            // Matches analyser range: -100 to -10 dB
            const minVal = -90;
            const maxVal = -20;

            // Draw each column (time frame)
            for (let t = 0; t < spectrogramBuffer.length; t++) {
                const frame = spectrogramBuffer[t];
                const x = Math.floor(t * width / SPECTROGRAM_HISTORY);

                for (let f = 0; f < MEL_BINS; f++) {
                    // Normalize to 0-1 with fixed range
                    let intensity = (frame[f] - minVal) / (maxVal - minVal);
                    intensity = Math.max(0, Math.min(1, intensity));

                    // Slight contrast boost
                    intensity = Math.pow(intensity, 0.8);

                    // Color mapping: black -> blue -> magenta -> red -> orange -> yellow -> white
                    let r, g, b;
                    if (intensity < 0.15) {
                        // Black to dark blue
                        const t = intensity / 0.15;
                        r = 0;
                        g = 0;
                        b = Math.floor(80 * t);
                    } else if (intensity < 0.3) {
                        // Dark blue to blue
                        const t = (intensity - 0.15) / 0.15;
                        r = 0;
                        g = Math.floor(30 * t);
                        b = Math.floor(80 + 120 * t);
                    } else if (intensity < 0.45) {
                        // Blue to magenta
                        const t = (intensity - 0.3) / 0.15;
                        r = Math.floor(180 * t);
                        g = Math.floor(30 * (1 - t));
                        b = Math.floor(200 - 40 * t);
                    } else if (intensity < 0.6) {
                        // Magenta to red
                        const t = (intensity - 0.45) / 0.15;
                        r = Math.floor(180 + 75 * t);
                        g = 0;
                        b = Math.floor(160 - 160 * t);
                    } else if (intensity < 0.75) {
                        // Red to orange
                        const t = (intensity - 0.6) / 0.15;
                        r = 255;
                        g = Math.floor(120 * t);
                        b = 0;
                    } else if (intensity < 0.9) {
                        // Orange to yellow
                        const t = (intensity - 0.75) / 0.15;
                        r = 255;
                        g = Math.floor(120 + 135 * t);
                        b = 0;
                    } else {
                        // Yellow to white
                        const t = (intensity - 0.9) / 0.1;
                        r = 255;
                        g = 255;
                        b = Math.floor(255 * t);
                    }

                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

                    // Draw from bottom (low freq) to top (high freq)
                    const y = height - Math.floor((f + 1) * height / MEL_BINS);
                    ctx.fillRect(x, y, colWidth, rowHeight);
                }
            }
        }

        function drawCursor() {
            if (!isTouching) return;

            const gradient = ctx.createRadialGradient(cursorX, cursorY, 5, cursorX, cursorY, 60);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(0, 255, 204, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 255, 204, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath(); ctx.arc(cursorX, cursorY, 60, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(cursorX, cursorY, 5, 0, Math.PI * 2); ctx.fill();
        }

        function addRipple(x, y) {
            ripples.push({ x, y, r: 10, o: 1.0 });
        }

        function drawRipples() {
            ctx.lineWidth = 2;
            for(let i = ripples.length - 1; i >= 0; i--) {
                let rip = ripples[i];
                ctx.strokeStyle = `rgba(0, 255, 204, ${rip.o})`;
                ctx.beginPath(); ctx.arc(rip.x, rip.y, rip.r, 0, Math.PI * 2); ctx.stroke();
                rip.r += 2;
                rip.o -= 0.02;
                if(rip.o <= 0) ripples.splice(i, 1);
            }
        }

        function animate() {
            // Clear with solid background for spectrogram
            ctx.fillStyle = 'rgb(5, 5, 10)';
            ctx.fillRect(0, 0, width, height);

            drawSpectrogram();
            drawGrid();
            drawRipples();
            drawCursor();

            if (!isTouching && Math.random() > 0.95) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.arc(Math.random()*width, Math.random()*height, Math.random()*2, 0, Math.PI*2);
                ctx.fill();
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * INTERACTION
         */
        const audio = new AudioEngine();
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('startBtn');
        let hasStarted = false;

        function initApp(e) {
            if(hasStarted) return;
            hasStarted = true;

            // Prevent phantom clicks if both events fire
            if(e && e.type === 'touchstart') e.preventDefault();

            // Request permissions FIRST, synchronously in user gesture
            // Then handle results and init audio
            const needsOrientationPermission = typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function';
            const needsMotionPermission = typeof DeviceMotionEvent !== 'undefined' &&
                typeof DeviceMotionEvent.requestPermission === 'function';

            if (needsOrientationPermission || needsMotionPermission) {
                // iOS 13+ path - request permissions synchronously in gesture handler
                const promises = [];

                if (needsOrientationPermission) {
                    promises.push(
                        DeviceOrientationEvent.requestPermission()
                            .then(state => {
                                if (state === 'granted') {
                                    window.addEventListener('deviceorientation', handleOrientation, true);
                                }
                                return 'o:' + state;
                            })
                            .catch(err => 'o:' + (err.name || err.message || 'err').substring(0, 15))
                    );
                }

                if (needsMotionPermission) {
                    promises.push(
                        DeviceMotionEvent.requestPermission()
                            .then(state => {
                                if (state === 'granted') {
                                    window.addEventListener('devicemotion', handleMotion, true);
                                }
                                return 'm:' + state;
                            })
                            .catch(err => 'm:' + (err.name || err.message || 'err').substring(0, 15))
                    );
                }

                Promise.all(promises).then(results => {
                    document.getElementById('val-motion').innerText = results.join(' ');
                });
            } else {
                // Non-iOS - just add listeners directly
                if (typeof DeviceOrientationEvent !== 'undefined') {
                    window.addEventListener('deviceorientation', handleOrientation, true);
                }
                if (typeof DeviceMotionEvent !== 'undefined') {
                    window.addEventListener('devicemotion', handleMotion, true);
                }
                document.getElementById('val-motion').innerText = 'auto';
            }

            // Init audio (also needs user gesture)
            audio.init();
            audio.resume();

            overlay.classList.add('hidden');
            document.getElementById('modeSelector').style.display = 'flex';
            initModeSelector();
            animate();
        }

        function initModeSelector() {
            const buttons = document.querySelectorAll('.mode-btn');
            buttons.forEach(btn => {
                const handler = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    audio.initMode(btn.dataset.mode);
                };
                btn.addEventListener('click', handler);
                btn.addEventListener('touchend', handler);
            });
        }

        function handleOrientation(e) {
            audio.updateOrientation(e.beta, e.gamma);
        }

        function handleMotion(e) {
            // Use accelerationIncludingGravity as fallback (more widely available)
            const acc = e.acceleration || e.accelerationIncludingGravity;
            audio.updateMotion(acc, e.rotationRate);
        }

        // Use touchend for iOS (fires like a click, valid user gesture)
        // Plus click for desktop fallback
        startBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            initApp(e);
        }, { passive: false });
        startBtn.addEventListener('click', initApp);

        // Track active touches
        const activeTouches = new Map();

        function handleStart(x, y, touchId = 0) {
            // Ignore touches in the mode selector area
            if (y > height - 60) return;

            isTouching = true;
            cursorX = x;
            cursorY = y;
            const normX = x / width;
            const normY = 1 - (y / (height - 60)); // Account for mode selector

            if (audio.ctx) {
                audio.start(touchId);
                audio.update(normX, Math.max(0, Math.min(1, normY)), touchId);
            }

            activeTouches.set(touchId, { x, y });
            addRipple(x, y);
        }

        function handleMove(x, y, touchId = 0) {
            if (!activeTouches.has(touchId)) return;

            cursorX = x;
            cursorY = y;
            const normX = x / width;
            const normY = 1 - (y / (height - 60));

            audio.update(normX, Math.max(0, Math.min(1, normY)), touchId);
            activeTouches.set(touchId, { x, y });

            if (Math.random() > 0.9) addRipple(x, y);
        }

        function handleEnd(touchId = 0) {
            activeTouches.delete(touchId);
            audio.stop(touchId);

            if (activeTouches.size === 0) {
                isTouching = false;
            }
        }

        // Mouse events (single touch only)
        window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY, 'mouse'));
        window.addEventListener('mousemove', e => {
            if (activeTouches.has('mouse')) handleMove(e.clientX, e.clientY, 'mouse');
        });
        window.addEventListener('mouseup', () => handleEnd('mouse'));

        // Touch events (multi-touch support)
        window.addEventListener('touchstart', e => {
            // Don't intercept touches on mode selector buttons
            if (e.target.closest('.mode-selector')) return;

            e.preventDefault();
            for (const touch of e.changedTouches) {
                handleStart(touch.clientX, touch.clientY, touch.identifier);
            }
        }, { passive: false });

        window.addEventListener('touchmove', e => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                handleMove(touch.clientX, touch.clientY, touch.identifier);
            }
        }, { passive: false });

        window.addEventListener('touchend', e => {
            if (e.target.closest('.mode-selector')) return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                handleEnd(touch.identifier);
            }
        });

        window.addEventListener('touchcancel', e => {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                handleEnd(touch.identifier);
            }
        });

    </script>
</body>
</html>